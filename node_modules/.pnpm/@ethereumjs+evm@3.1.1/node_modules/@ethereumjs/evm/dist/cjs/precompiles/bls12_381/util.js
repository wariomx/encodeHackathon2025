"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.leading16ZeroBytesCheck = exports.moduloLengthCheck = exports.equalityLengthCheck = exports.msmGasUsed = exports.gasCheck = void 0;
const util_1 = require("@ethereumjs/util");
const constants_js_1 = require("./constants.js");
const ZERO_BYTES_16 = new Uint8Array(16);
/**
 * Checks that the gas used remain under the gas limit.
 *
 * @param opts
 * @param gasUsed
 * @param pName
 * @returns
 */
const gasCheck = (opts, gasUsed, pName) => {
    if (opts._debug !== undefined) {
        opts._debug(`Run ${pName} precompile data=${(0, util_1.short)(opts.data)} length=${opts.data.length} gasLimit=${opts.gasLimit} gasUsed=${gasUsed}`);
    }
    if (opts.gasLimit < gasUsed) {
        if (opts._debug !== undefined) {
            opts._debug(`${pName} failed: OOG`);
        }
        return false;
    }
    return true;
};
exports.gasCheck = gasCheck;
/**
 * Calculates the gas used for the MSM precompiles based on the number of pairs and
 * calculating in some discount in relation to the number of pairs.
 *
 * @param numPairs
 * @param gasUsedPerPair
 * @returns
 */
const msmGasUsed = (numPairs, gasUsedPerPair) => {
    const gasDiscountMax = constants_js_1.BLS_GAS_DISCOUNT_PAIRS[constants_js_1.BLS_GAS_DISCOUNT_PAIRS.length - 1][1];
    let gasDiscountMultiplier;
    if (numPairs <= constants_js_1.BLS_GAS_DISCOUNT_PAIRS.length) {
        if (numPairs === 0) {
            gasDiscountMultiplier = 0; // this implicitly sets gasUsed to 0 as per the EIP.
        }
        else {
            gasDiscountMultiplier = constants_js_1.BLS_GAS_DISCOUNT_PAIRS[numPairs - 1][1];
        }
    }
    else {
        gasDiscountMultiplier = gasDiscountMax;
    }
    // (numPairs * multiplication_cost * discount) / multiplier
    return (BigInt(numPairs) * gasUsedPerPair * BigInt(gasDiscountMultiplier)) / BigInt(1000);
};
exports.msmGasUsed = msmGasUsed;
/**
 * Checks that the length of the provided data is equal to `length`.
 *
 * @param opts
 * @param length
 * @param pName
 * @returns
 */
const equalityLengthCheck = (opts, length, pName) => {
    if (opts.data.length !== length) {
        if (opts._debug !== undefined) {
            opts._debug(`${pName} failed: Invalid input length length=${opts.data.length} (expected: ${length})`);
        }
        return false;
    }
    return true;
};
exports.equalityLengthCheck = equalityLengthCheck;
/**
 * Checks that the total length of the provided data input can be subdivided into k equal parts
 * with `length` (without leaving some remainder bytes).
 *
 * @param opts
 * @param length
 * @param pName
 * @returns
 */
const moduloLengthCheck = (opts, length, pName) => {
    if (opts.data.length % length !== 0) {
        if (opts._debug !== undefined) {
            opts._debug(`${pName} failed: Invalid input length length=${opts.data.length} (expected: ${length}*k bytes)`);
        }
        return false;
    }
    return true;
};
exports.moduloLengthCheck = moduloLengthCheck;
/**
 * BLS-specific zero check to check that the top 16 bytes of a 64 byte field element provided
 * are always zero (see EIP notes on field element encoding).
 *
 * Zero byte ranges are expected to be passed in the following format (and so each referencing
 * 16-byte ranges):
 *
 * ```ts
 * const zeroByteRanges = [
 *   [0, 16],
 *   [64, 80],
 *   [128, 144]
 *
 * ]
 * ```
 *
 * @param opts
 * @param zeroByteRanges
 * @param pName
 * @param pairStart
 * @returns
 */
const leading16ZeroBytesCheck = (opts, zeroByteRanges, pName, pairStart = 0) => {
    for (const index in zeroByteRanges) {
        const slicedBuffer = opts.data.subarray(zeroByteRanges[index][0] + pairStart, zeroByteRanges[index][1] + pairStart);
        if (!((0, util_1.equalsBytes)(slicedBuffer, ZERO_BYTES_16) === true)) {
            if (opts._debug !== undefined) {
                opts._debug(`${pName} failed: Point not on curve`);
            }
            return false;
        }
    }
    return true;
};
exports.leading16ZeroBytesCheck = leading16ZeroBytesCheck;
//# sourceMappingURL=util.js.map