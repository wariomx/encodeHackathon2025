import { Address } from '@ethereumjs/util';
import type { PrecompileFunc } from './precompiles/index.js';
import type { AccessWitnessInterface } from '@ethereumjs/common';
import type { PrefixedHexString } from '@ethereumjs/util';
interface MessageOpts {
    to?: Address;
    value?: bigint;
    caller?: Address;
    gasLimit: bigint;
    data?: Uint8Array;
    depth?: number;
    code?: Uint8Array | PrecompileFunc;
    codeAddress?: Address;
    isStatic?: boolean;
    isCompiled?: boolean;
    salt?: Uint8Array;
    /**
     * A set of addresses to selfdestruct, see {@link Message.selfdestruct}
     */
    selfdestruct?: Set<PrefixedHexString>;
    /**
     * Map of addresses which were created (used in EIP 6780)
     */
    createdAddresses?: Set<PrefixedHexString>;
    delegatecall?: boolean;
    authcallOrigin?: Address;
    gasRefund?: bigint;
    blobVersionedHashes?: Uint8Array[];
    accessWitness?: AccessWitnessInterface;
}
export declare class Message {
    to?: Address;
    value: bigint;
    caller: Address;
    gasLimit: bigint;
    data: Uint8Array;
    depth: number;
    code?: Uint8Array | PrecompileFunc;
    _codeAddress?: Address;
    isStatic: boolean;
    isCompiled: boolean;
    salt?: Uint8Array;
    containerCode?: Uint8Array; /** container code for EOF1 contracts - used by CODECOPY/CODESIZE */
    chargeCodeAccesses?: boolean;
    /**
     * Set of addresses to selfdestruct. Key is the unprefixed address.
     */
    selfdestruct?: Set<PrefixedHexString>;
    /**
     * Map of addresses which were created (used in EIP 6780)
     */
    createdAddresses?: Set<PrefixedHexString>;
    delegatecall: boolean;
    /**
     * This is used to store the origin of the AUTHCALL,
     * the purpose is to figure out where `value` should be taken from (not from `caller`)
     */
    authcallOrigin?: Address;
    gasRefund: bigint;
    /**
     * List of versioned hashes if message is a blob transaction in the outer VM
     */
    blobVersionedHashes?: Uint8Array[];
    accessWitness?: AccessWitnessInterface;
    constructor(opts: MessageOpts);
    /**
     * Note: should only be called in instances where `_codeAddress` or `to` is defined.
     */
    get codeAddress(): Address;
}
export declare type MessageWithTo = Message & Pick<Required<MessageOpts>, 'to'>;
export {};
//# sourceMappingURL=message.d.ts.map