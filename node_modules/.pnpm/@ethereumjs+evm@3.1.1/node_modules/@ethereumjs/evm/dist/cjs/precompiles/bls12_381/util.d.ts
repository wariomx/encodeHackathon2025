import type { PrecompileInput } from '../types.js';
/**
 * Checks that the gas used remain under the gas limit.
 *
 * @param opts
 * @param gasUsed
 * @param pName
 * @returns
 */
export declare const gasCheck: (opts: PrecompileInput, gasUsed: bigint, pName: string) => boolean;
/**
 * Calculates the gas used for the MSM precompiles based on the number of pairs and
 * calculating in some discount in relation to the number of pairs.
 *
 * @param numPairs
 * @param gasUsedPerPair
 * @returns
 */
export declare const msmGasUsed: (numPairs: number, gasUsedPerPair: bigint) => bigint;
/**
 * Checks that the length of the provided data is equal to `length`.
 *
 * @param opts
 * @param length
 * @param pName
 * @returns
 */
export declare const equalityLengthCheck: (opts: PrecompileInput, length: number, pName: string) => boolean;
/**
 * Checks that the total length of the provided data input can be subdivided into k equal parts
 * with `length` (without leaving some remainder bytes).
 *
 * @param opts
 * @param length
 * @param pName
 * @returns
 */
export declare const moduloLengthCheck: (opts: PrecompileInput, length: number, pName: string) => boolean;
/**
 * BLS-specific zero check to check that the top 16 bytes of a 64 byte field element provided
 * are always zero (see EIP notes on field element encoding).
 *
 * Zero byte ranges are expected to be passed in the following format (and so each referencing
 * 16-byte ranges):
 *
 * ```ts
 * const zeroByteRanges = [
 *   [0, 16],
 *   [64, 80],
 *   [128, 144]
 *
 * ]
 * ```
 *
 * @param opts
 * @param zeroByteRanges
 * @param pName
 * @param pairStart
 * @returns
 */
export declare const leading16ZeroBytesCheck: (opts: PrecompileInput, zeroByteRanges: number[][], pName: string, pairStart?: number) => boolean;
//# sourceMappingURL=util.d.ts.map